// Generated by CoffeeScript 1.12.7
let EventEmitter;

const bind = (fn, me) => function () { return fn.apply(me, arguments); };

EventEmitter = require('events').EventEmitter;

class Watcher extends EventEmitter {
	constructor(etcd, key, index, options) {
		super();
		this.etcd = etcd;
		this.key = key;
		this.index = index != null ? index : null;
		this.options = options != null ? options : {};
		this._retry = bind(this._retry, this);
		this._respHandler = bind(this._respHandler, this);
		this._resync = bind(this._resync, this);
		this._unexpectedData = bind(this._unexpectedData, this);
		this._valueChanged = bind(this._valueChanged, this);
		this._missingValue = bind(this._missingValue, this);
		this._error = bind(this._error, this);
		this._watch = bind(this._watch, this);
		this.stop = bind(this.stop, this);
		this.stopped = false;
		this.retryAttempts = 0;
		this._watch();
	}

	stop() {
		this.stopped = true;
		this.request.abort();
		return this.emit('stop', `Watcher for '${this.key}' aborted.`);
	}

	_watch() {
		if (this.index === null) {
			this.request = this.etcd.watch(this.key, this.options, this._respHandler);
		} else {
			this.request = this.etcd.watchIndex(this.key, this.index, this.options, this._respHandler);
		}
		return this.request
	}

	_error(err) {
		let error;
		error = new Error('Connection error, reconnecting.');
		error.error = err;
		error.reconnectCount = this.retryAttempts;
		this.emit('reconnect', error);
		return this._retry();
	}

	_missingValue(headers) {
		let error;
		error = new Error('Etcd timed out watcher, reconnecting.');
		error.headers = headers;
		this.retryAttempts = 0;
		this.emit('reconnect', error);
		return this._watch();
	}

	_valueChanged(val, headers) {
		this.retryAttempts = 0;
		this.index = val.node.modifiedIndex + 1;
		this.emit('change', val, headers);
		if (val.action != null) {
			this.emit(val.action, val, headers);
		}
		return this._watch();
	}

	_unexpectedData(val, headers) {
		let error;
		error = new Error('Received unexpected response');
		error.response = val;
		this.emit('error', error);
		return this._retry();
	}

	_resync(err) {
		this.index = err.error.index;
		this.retryAttempts = 0;
		this.emit('resync', err);
		return this._watch();
	}

	_respHandler(err, val, headers) {
		let ref;
		let ref1;
		if (this.stopped) {
			return;
		}
		if ((err != null ? err.errorCode : void 0) === 401 && (((ref = err.error) != null ? ref.index : void 0) != null)) {
			return this._resync(err);
		} else if (err) {
			return this._error(err);
		} else if (((headers != null ? headers['x-etcd-index'] : void 0) != null) && (val == null)) {
			return this._missingValue(headers);
		} else if ((val != null ? (ref1 = val.node) != null ? ref1.modifiedIndex : void 0 : void 0) != null) {
			return this._valueChanged(val, headers);
		} else {
			return this._unexpectedData(val, headers);
		}
	}

	_retry() {
		let timeout;
		timeout = (2 ** this.retryAttempts * 300) + (Math.round(Math.random() * 1000));
		setTimeout(this._watch, timeout);
		return this.retryAttempts++;
	}
}

exports = module.exports = Watcher;
